<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GridPath: A Quoridor Clone</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
    <style>
      @font-face {
        font-family: "returnofganon";
        src: url("assets/fonts/returnofganon.woff2") format("woff2"),
          url("assets/fonts/returnofganon.woff") format("woff");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      html,
      body {
        height: 100%;
      }
      body,
      .wall-bar,
      #turnIndicator,
      #instructions {
        font-family: "returnofganon", Consolas, monospace;
        font-size: 28px;
      }

      body {
        margin: 0;
        background-size: cover;
        padding: 0;
        background: #000;
        font-family: Consolas, monospace;
        color: white;
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr auto; /* header | main layout | footer */

        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: url("assets/images/city.jpg") no-repeat center bottom;
        background-size: cover;
        filter: blur(8px);
        z-index: -2;
      }

      body::after {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.4); /* optional blue tint overlay */
        z-index: -1;
      }

      /* Header title */
      header {
        text-align: center;
        font-family: Consolas, monospace bolder;
        margin-top: 0px;
        color: #00ffcc;
        font-size: 2.5rem;
      }

      .logo {
        background: url("assets/ui/favicon.png") no-repeat center center;
        background-size: contain;
        width: 1024px;
        height: 225px;
        display: flex;
        justify-content: center;
        text-indent: -9999px;
        overflow: hidden;
        white-space: nowrap;
        margin: 0 auto; /* center block element */
        display: block;
      }

      .wall-counts {
        display: flex;
        justify-content: space-around;
        margin: 10px 0;
        padding: 0 20px;
        font-size: 18px;
        color: white;
      }

      .wall-bar {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .wall-unit {
        width: 20px;
        height: 20px;
        background-color: #00ffcc;
        border: 1px solid #fff;
        border-radius: 2px;
      }

      /* Layout between canvas and instructions */
      .layout {
        display: flex;
        flex-grow: 1;
        justify-content: center;
        align-items: center;
        gap: 0;
        padding: 20px;
        flex-wrap: wrap;
        height: 100%; /* allow it to expand in the flex container */
        width: 105%; /* allow it to expand in the flex container */

        box-sizing: border-box; /* Fill full vertical space */
      }

      /* Canvas area */
      .canvas-wrapper {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .canvas-wrapper {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-shrink: 0;
      }

      /* Phaser canvas style */
      canvas {
        box-shadow: 0px 8px 24px rgba(0, 0, 0, 0.6);
        background: #000000ac;
        padding: 18px;
        border-radius: 8px;
      }

      #turnIndicator,
      #instructions {
        font-family: sans-serif;
        background-color: rgba(0, 0, 0, 0);
        color: white;
        padding: 35px;
        border-radius: 8px;
        max-width: 260px;
        font-size: 15px;
        line-height: 20px;

        display: flex;
        align-items: center;
        justify-content: center;
        text-align: left;
        height: fit-content;
      }

      #turnIndicator {
        justify-content: flex-end;
        opacity: 0;
      }

      #instructions {
        justify-content: flex-start;
      }
      @media (max-width: 768px) {
        .layout {
          flex-direction: column;
          align-items: center;
        }

        #turnIndicator,
        #instructions {
          max-width: 90vw;
          justify-content: center;
          text-align: center;
        }
      }

      .site-footer {
        text-align: center;
        padding: 2px;
        font-size: 14px;
        color: #aeaeae;
        background-color: #0000006f; /* optional light background */
        border-top: 1px solid #343030; /* optional top border */
      }

      .site-footer a {
        color: #007acc; /* or whatever color fits your theme */
        text-decoration: none;
      }

      .site-footer a:hover {
        text-decoration: underline;
      }

      .made-by {
        display: inline-block;
        margin-top: 4px; /* Adjust spacing here */
      }
    </style>
  </head>
  <body>
    <header>
      <h1 class="logo">GridPath: A Quoridor Clone</h1>
    </header>
    <div class="wall-counts">
      <div id="player1Walls" class="wall-bar">Player 1 Walls:</div>
      <div id="player2Walls" class="wall-bar">Player 2 Walls:</div>
    </div>
    <div class="layout">
      <div class="side-column" id="turnIndicator">Current Turn: Player 1</div>

      <div class="canvas-wrapper">
        <div id="game-container"></div>
      </div>

      <div id="instructions">
        <div>
          Instructions: <br /><strong>Reach the side with your color.</strong
          ><br />
          <br />- Use the mouse or directional keys + SPACEBAR to move or place
          walls. <br />- Press "W" to enter wall placement mode and prevent your
          enemy from advancing. <br />- Press "V" to switch between horizontal
          and vertical wall orientation.
          <br />
          - Click or press SPACEBAR on a highlighted wall position to place it.
          <br />(If it flashes, it's not a valid move) <br />- Press "P" to
          change the soundtrack. <br />- Press "M" to mute/unmute the music.
          <br />- Press "ESC" or "R" to restart the game.
        </div>
      </div>
    </div>

    <footer class="site-footer">
      <p>
        <a href="https://github.com/an-dr32/quoridor_game.git" target="_blank">
          https://github.com/an-dr32/quoridor_game.git
        </a>
        <br />
        <span class="made-by">Made by: Andres DM AKA L0gg3r</span>
      </p>
    </footer>

    <script>
      const GRID_SIZE = 9;
      const CELL_SIZE = 64;
      const WALL_THICKNESS = 10;
      const MAX_WALLS = 10;

      let firstLoad = true;

      let bgMusic = null;
      let menuIntroMusic = null;
      let allTracks = [];
      let currentTrackIndex = 0;
      let musicMuted = false;

      class QuoridorScene extends Phaser.Scene {
        constructor() {
          super("QuoridorScene");
        }

        preload() {
          // Load images
          this.load.image("logo", "assets/images/logo.png");

          // Soundtrack Music
          this.load.audio("bgMusic1", "assets/sounds/bgMusic1.ogg");
          this.load.audio("bgMusic2", "assets/sounds/bgMusic2.ogg");
          this.load.audio("bgMusic3", "assets/sounds/bgMusic3.ogg");
          this.load.audio("bgMusic4", "assets/sounds/bgMusic4.ogg");
          this.load.audio("bgMusic5", "assets/sounds/bgMusic5.ogg");
          this.load.audio("bgMusic6", "assets/sounds/bgMusic6.ogg");
          this.load.audio("bgMusic7", "assets/sounds/bgMusic7.ogg");
          this.load.audio("bgMusic8", "assets/sounds/bgMusic8.ogg");

          this.load.audio("keyboardSound", "assets/sounds/key.ogg");
          this.load.audio("pluckSound", "assets/sounds/pluck.ogg");
          this.load.audio("moveSound", "assets/sounds/movement.ogg");
          this.load.audio("wallSound", "assets/sounds/wall.ogg");
          this.load.audio("invalidSound", "assets/sounds/invalid.ogg");
          this.load.audio("restartSound", "assets/sounds/restart.ogg");
          this.load.audio("victorySound", "assets/sounds/victory.ogg");
        }

        create(data) {
          if (firstLoad || (data && data.logoFromRestart)) {
            this.logo = this.add.image(
              this.scale.width / 2,
              this.scale.height / 2,
              "logo"
            );
            this.logo.setDepth(100);
            this.logo.setAlpha(1);
            this.logo.setScale(1);

            this.tweens.add({
              targets: this.logo,
              alpha: 0,
              duration: 400,
              delay: 600,
              onComplete: () => {
                this.logo.destroy();
              },
            });

            firstLoad = false; // prevent showing logo on future non-restart scene calls
          }

          this.flashTween = null; // Initialize flashTween to null

          this.isPointerDown = false; // Track pointer state
          this.pendingWallPlacement = null; // Track pending wall placement
          this.readyToPlaceWall = false; // Track if wall placement is ready

          this.pluckSound = this.sound.add("pluckSound", {
            loop: false,
            volume: 1,
          });
          this.keySound = this.sound.add("keyboardSound", {
            loop: false,
            volume: 1,
          });
          this.moveSound = this.sound.add("moveSound", {
            loop: false,
            volume: 1,
          });
          this.wallSound = this.sound.add("wallSound", {
            loop: false,
            volume: 1,
          });
          this.invalidSound = this.sound.add("invalidSound", {
            loop: false,
            volume: 1,
          });
          this.restartSound = this.sound.add("restartSound", {
            loop: false,
            volume: 1,
          });

          this.invalidSoundCooldown = false;
          this.lastInvalidTime = 0;

          // Background music setup
          allTracks = [
            { key: "bgMusic1", name: "12 12 inst mix ab oz - Mobygratis" },
            { key: "bgMusic2", name: "1960s 2 house inst ab oz - Mobygratis" },
            { key: "bgMusic3", name: "asteroid b inst mix ab oz - Mobygratis" },
            { key: "bgMusic4", name: "bunt poll 102 - Mobygratis" },
            { key: "bgMusic5", name: "by choice inst mix ab oz - Mobygratis" },
            { key: "bgMusic6", name: "clef inst mix ab oz - Mobygratis" },
            { key: "bgMusic7", name: "hafa 126 - Mobygratis" },
            { key: "bgMusic8", name: "hidden inst mix ab oz - Mobygratis" },
          ];

          const savedIndex = localStorage.getItem("selectedTrackIndex");
          currentTrackIndex = savedIndex !== null ? parseInt(savedIndex) : 0;

          const savedMuted = localStorage.getItem("musicMuted");
          musicMuted = savedMuted === "true";

          const selectedTrack = allTracks[currentTrackIndex] || {
            key: "bgMusic",
            name: "Default Track",
          };

          if (!bgMusic || !bgMusic.isPlaying) {
            bgMusic = this.sound.add(selectedTrack.key, {
              loop: true,
              volume: musicMuted ? 0 : 0.5,
            });
            bgMusic.play();
          }

          // Track label in the center of canvas
          const centerX = this.cameras.main.width / 2;
          const centerY = this.cameras.main.height / 2;

          this.trackLabel = this.add
            .text(centerX, centerY, selectedTrack.name, {
              fontFamily: "returnofganon",
              fontSize: "25px",
              fill: "#aaa",
              backgroundColor: "#00000088",
              padding: { x: 10, y: 5 },
            })
            .setOrigin(0.5)
            .setVisible(false)
            .setAlpha(0)
            .setDepth(100);

          this.input.keyboard.on("keydown-P", () => {
            currentTrackIndex = (currentTrackIndex + 1) % allTracks.length;
            localStorage.setItem("selectedTrackIndex", currentTrackIndex);

            const nextTrack = allTracks[currentTrackIndex];

            if (this.sound.get(nextTrack.key)) {
              if (bgMusic) {
                bgMusic.stop();
                bgMusic.destroy();
              }
              bgMusic = this.sound.add(nextTrack.key, {
                loop: true,
                volume: musicMuted ? 0 : 1,
              });
              bgMusic.play();
              this.showTrackLabel(nextTrack.name);
            } else {
              // Corrected dynamic loading:
              this.load.audio(
                nextTrack.key,
                `assets/sounds/bgMusic${currentTrackIndex + 1}.ogg`
              );
              this.load.once("complete", () => {
                if (bgMusic) {
                  bgMusic.stop();
                  bgMusic.destroy();
                }
                bgMusic = this.sound.add(nextTrack.key, {
                  loop: true,
                  volume: musicMuted ? 0 : 1,
                });
                bgMusic.play();
                this.showTrackLabel(nextTrack.name);
              });
              this.load.start();
            }
          });

          this.input.keyboard.on("keydown-M", () => {
            musicMuted = !musicMuted;
            localStorage.setItem("musicMuted", musicMuted);

            if (bgMusic) {
              bgMusic.setVolume(musicMuted ? 0 : 1);
            }

            if (menuIntroMusic) {
              menuIntroMusic.setVolume(musicMuted ? 0 : 1);
            }
          });

          // Restart switch
          this.input.keyboard.on("keydown", (event) => {
            switch (event.code) {
              case "Escape":
              case "KeyR":
                this.handleRestart();
                break;
            }
          });

          // Game setup
          this.grid = [];
          this.gridHighlights = [];
          this.currentPlayer = 0;
          this.wallMode = false;
          this.wallOrientation = "H";
          this.walls = [];
          this.wallMap = new Set();
          this.wallCounts = [MAX_WALLS, MAX_WALLS];
          this.ghostWall = null;
          this.pawns = [
            { x: 4, y: 0, sprite: null },
            { x: 4, y: 8, sprite: null },
          ];
          this.wallColors = [0xdfff00, 0xff007f]; //<-- Player's Colors -->
          this.highlightColors = [0xcae038, 0xfffbddd]; //<-- Movement's Colors -->

          this.drawGrid();
          this.drawPawns();
          this.updateTurnIndicator();
          this.highlightMovableCells();

          // New: Selector setup
          this.selector = this.add.rectangle(
            0,
            0,
            CELL_SIZE,
            CELL_SIZE,
            this.wallColors[this.currentPlayer],
            0.4
          );
          this.selector.setStrokeStyle(2, 0xffffff);
          this.selector.setDepth(2);
          this.selectorVisible = true;
          this.lastWallSelectorPositions = [
            null, // Player 1
            null, // Player 2
          ];

          this.moveCooldown = 0;

          this.selector.gridX = this.pawns[this.currentPlayer].x;
          this.selector.gridY = this.pawns[this.currentPlayer].y;
          this.updateSelectorPosition();

          // Movement keys
          this.cursors = this.input.keyboard.createCursorKeys();

          // Confirm keys
          this.input.keyboard.on("keydown-SPACE", () => {
            this.handleSelectorAction();
          });

          this.input.keyboard.on("keydown-ENTER", () => {
            this.handleSelectorAction();
          });

          this.input.on("gameobjectdown", this.handleClick, this);

          this.input.keyboard.on("keydown-W", () => {
            if (this.wallMode) {
              // âž¡ï¸ Leaving wall mode
              this.wallMode = false;

              // Save last wall selector position for the current player
              this.lastWallSelectorPositions[this.currentPlayer] = {
                x: this.selector.gridX,
                y: this.selector.gridY,
              };

              if (this.ghostWall) {
                this.ghostWall.destroy();
                this.ghostWall = null;
              }

              this.highlightMovableCells();

              // Reset selector back to the pawn position
              this.selector.gridX = this.pawns[this.currentPlayer].x;
              this.selector.gridY = this.pawns[this.currentPlayer].y;
              this.updateSelectorPosition();
            } else if (this.wallCounts[this.currentPlayer] > 0) {
              // âž¡ï¸ Entering wall mode
              this.wallMode = true;
              this.clearHighlights();

              // Restore last wall selector position if it exists for current player
              const lastPos =
                this.lastWallSelectorPositions[this.currentPlayer];
              if (lastPos) {
                this.selector.gridX = lastPos.x;
                this.selector.gridY = lastPos.y;
              }
              this.updateSelectorPosition();
            }
            this.pluckSound.play();

            this.updateTurnIndicator();
          });

          this.input.keyboard.on("keydown-V", () => {
            if (this.wallMode) {
              this.wallOrientation = this.wallOrientation === "H" ? "V" : "H";
              this.updateGhostWall();
              this.updateTurnIndicator();
              this.pluckSound.play();
            }
          });

          this.input.on("pointermove", (pointer) => {
            if (!this.wallMode) {
              if (this.ghostWall) {
                this.ghostWall.destroy();
                this.ghostWall = null;
              }
              return;
            }

            const x = Math.floor(pointer.x / CELL_SIZE);
            const y = Math.floor(pointer.y / CELL_SIZE);

            const key = `${x},${y},${this.wallOrientation}`;
            const adjacentKey =
              this.wallOrientation === "H"
                ? `${x + 1},${y},H`
                : `${x},${y + 1},V`;

            if (x < 0 || y < 0 || x >= GRID_SIZE - 1 || y >= GRID_SIZE - 1) {
              if (this.ghostWall) this.ghostWall.setAlpha(0);
              this.pendingWallPlacement = null;
              return;
            }

            const isInvalid =
              this.wallMap.has(key) || this.wallMap.has(adjacentKey);

            if (isInvalid) {
              if (!this.flashTween && this.ghostWall) {
                this.flashTween = this.tweens.add({
                  targets: this.ghostWall,
                  alpha: { from: 0.2, to: 0.7 },
                  duration: 300,
                  yoyo: true,
                  repeat: 2,
                  onComplete: () => {
                    if (this.ghostWall) this.ghostWall.setAlpha(0.4);
                    this.flashTween = null;
                  },
                });
              }
              this.pendingWallPlacement = null;
              return;
            }

            if (!this.ghostWall) {
              this.ghostWall = this.add.rectangle(
                0,
                0,
                0,
                0,
                this.wallColors[this.currentPlayer]
              );
              this.ghostWall.setAlpha(0.4);
            }

            if (this.flashTween) {
              this.flashTween.stop();
              this.flashTween = null;
              if (this.ghostWall) this.ghostWall.setAlpha(0.4);
            }

            if (this.wallOrientation === "H") {
              this.ghostWall.setSize(CELL_SIZE * 2, WALL_THICKNESS);
              this.ghostWall.setPosition(
                x * CELL_SIZE + CELL_SIZE,
                y * CELL_SIZE + CELL_SIZE - WALL_THICKNESS / 2
              );
            } else {
              this.ghostWall.setSize(WALL_THICKNESS, CELL_SIZE * 2);
              this.ghostWall.setPosition(
                x * CELL_SIZE + CELL_SIZE - WALL_THICKNESS / 2,
                y * CELL_SIZE + CELL_SIZE
              );
            }

            this.ghostWall.setFillStyle(this.wallColors[this.currentPlayer]);
            this.ghostWall.setAlpha(0.4);
            this.pendingWallPlacement = { x, y };
          });

          this.renderWallBars = () => {
            const updateWallBar = (elementId, count, color) => {
              const container = document.getElementById(elementId);
              container.innerHTML = `Player ${
                elementId === "player1Walls" ? 1 : 2
              } Walls: `;
              for (let i = 0; i < count; i++) {
                const unit = document.createElement("div");
                unit.className = "wall-unit";
                unit.style.backgroundColor =
                  Phaser.Display.Color.IntegerToColor(color).rgba;
                container.appendChild(unit);
              }
            };

            updateWallBar(
              "player1Walls",
              this.wallCounts[0],
              this.wallColors[0]
            );
            updateWallBar(
              "player2Walls",
              this.wallCounts[1],
              this.wallColors[1]
            );
          };

          // âœ… Now call it
          this.renderWallBars();

          this.input.on("pointerdown", (pointer) => {
            this.isPointerDown = true;
            this.touchStart = {
              x: pointer.x,
              y: pointer.y,
              time: this.time.now,
            };
          });

          this.input.on("pointerup", (pointer) => {
            this.isPointerDown = false;

            const tapDistance = Phaser.Math.Distance.Between(
              pointer.x,
              pointer.y,
              this.touchStart?.x ?? 0,
              this.touchStart?.y ?? 0
            );
            const tapDuration = this.time.now - (this.touchStart?.time ?? 0);
            const isTouchTap = tapDistance < 10 && tapDuration < 300;

            if (
              this.wallMode &&
              this.pendingWallPlacement &&
              (this.readyToPlaceWall || isTouchTap)
            ) {
              const { x, y } = this.pendingWallPlacement;
              const placed = this.placeWall(x, y);

              if (placed) {
                this.wallMode = false;
                this.currentPlayer = 1 - this.currentPlayer;
                this.updateTurnIndicator();
                this.highlightMovableCells();
                this.wallSound.play();
              } else {
                this.playInvalidSoundOnce();

                if (!this.flashTween && this.ghostWall) {
                  this.flashTween = this.tweens.add({
                    targets: this.ghostWall,
                    alpha: { from: 0.2, to: 0.7 },
                    duration: 300,
                    yoyo: true,
                    repeat: 2,
                    onComplete: () => {
                      if (this.ghostWall) this.ghostWall.setAlpha(0.4);
                      this.flashTween = null;
                    },
                  });
                }
              }
            } else if (this.wallMode && (this.readyToPlaceWall || isTouchTap)) {
              // Pointer released in wall mode, but no pending placement â†’ invalid
              this.playInvalidSoundOnce();
            }

            this.pendingWallPlacement = null;
            this.readyToPlaceWall = false;
          });

          // Mark game as started
          this.gameStarted = true;
        }

        showTrackLabel(name) {
          if (!this.trackLabel) return;

          const centerX = this.cameras.main.width / 2;

          this.trackLabel.setText(`Track: ${name}`);
          this.trackLabel.setAlpha(1);
          this.trackLabel.setVisible(true);
          this.trackLabel.x = centerX;

          // Cancel any existing tween to avoid stacking
          if (this.trackLabelFade) {
            this.trackLabelFade.remove();
          }

          // Start fade out with vibration after delay
          this.trackLabelFade = this.time.delayedCall(3000, () => {
            this.tweens.add({
              targets: this.trackLabel,
              alpha: 0,
              duration: 800,
              ease: "Sine.easeInOut",
              onUpdate: (tween, target) => {
                target.x =
                  centerX + Math.sin(tween.progress * Math.PI * 12) * 4;
              },
              onComplete: (tween, targets) => {
                targets[0].setVisible(false);
                targets[0].x = centerX;
              },
            });
          });
        }
        handleRestart() {
          this.logoData = { showLogoOnCreate: true };

          this.logo = this.add.image(
            this.scale.width / 2,
            this.scale.height / 2,
            "logo"
          );
          this.logo.setDepth(100);
          this.logo.setAlpha(1);
          this.logo.setScale(1);

          this.tweens.add({
            targets: this.logo,
            alpha: { from: 0, to: 1 },
            duration: 100,
          });

          this.restartSound.play();

          this.time.delayedCall(1000, () => {
            this.scene.restart({ logoFromRestart: true });
          });
        }

        playInvalidSoundOnce() {
          if (this.invalidSoundCooldown) return;

          this.invalidSound.play();
          this.invalidSoundCooldown = true;

          // Reset cooldown after 300ms
          this.time.delayedCall(3000, () => {
            this.invalidSoundCooldown = false;
          });
        }

        drawGrid() {
          for (let y = 0; y < GRID_SIZE; y++) {
            this.grid[y] = [];
            for (let x = 0; x < GRID_SIZE; x++) {
              // Determine color based on row
              let fillColor = 0x2d2d2d; // default
              if (y === 0) fillColor = this.wallColors[1]; // Player 2's goal row
              if (y === GRID_SIZE - 1) fillColor = this.wallColors[0]; // Player 1's goal row

              let rect = this.add.rectangle(
                x * CELL_SIZE + CELL_SIZE / 2,
                y * CELL_SIZE + CELL_SIZE / 2,
                CELL_SIZE,
                CELL_SIZE,
                fillColor
              );

              if (y === 0 || y === GRID_SIZE - 1) {
                rect.setAlpha(0.7); // more subtle (0 = invisible, 1 = fully opaque)
              }

              rect.setStrokeStyle(2, 0x7df9ff); // Light blue outline
              rect.setInteractive();
              rect.gridX = x;
              rect.gridY = y;
              this.grid[y][x] = rect;
            }
          }
        }

        drawPawns() {
          this.pawns.forEach((pawn, index) => {
            pawn.sprite = this.add.circle(
              pawn.x * CELL_SIZE + CELL_SIZE / 2,
              pawn.y * CELL_SIZE + CELL_SIZE / 2,
              20,
              this.wallColors[index]
            );
          });
        }

        clearHighlights() {
          this.gridHighlights.forEach((h) => {
            if (h.rect && h.rect.destroy) {
              h.rect.destroy();
            }
          });
          this.gridHighlights = [];
        }

        highlightMovableCells() {
          this.clearHighlights();
          const p = this.pawns[this.currentPlayer];
          const o = this.pawns[1 - this.currentPlayer];
          const dirs = [
            { dx: 1, dy: 0 },
            { dx: -1, dy: 0 },
            { dx: 0, dy: 1 },
            { dx: 0, dy: -1 },
          ];

          for (const dir of dirs) {
            const nx = p.x + dir.dx,
              ny = p.y + dir.dy;
            if (nx < 0 || ny < 0 || nx >= GRID_SIZE || ny >= GRID_SIZE)
              continue;
            if (this.isWallBetween(p.x, p.y, nx, ny)) continue;

            if (nx === o.x && ny === o.y) {
              const jx = o.x + dir.dx,
                jy = o.y + dir.dy;
              console.log(
                `\n[JUMP TRY] from (${p.x},${p.y}) over (${o.x},${o.y}) to (${jx},${jy})`
              );
              const block1 = this.isWallBetween(p.x, p.y, o.x, o.y);
              const block2 = this.isWallBetween(o.x, o.y, jx, jy);
              console.log(
                `  walls? first segment: ${block1}, second: ${block2}`
              );
              if (
                jx >= 0 &&
                jy >= 0 &&
                jx < GRID_SIZE &&
                jy < GRID_SIZE &&
                !block1 &&
                !block2
              ) {
                const highlight = this.add.rectangle(
                  jx * CELL_SIZE + CELL_SIZE / 2,
                  jy * CELL_SIZE + CELL_SIZE / 2,
                  CELL_SIZE,
                  CELL_SIZE,
                  this.highlightColors[this.currentPlayer],
                  0.4
                );
                highlight.setDepth(1);
                this.gridHighlights.push({ x: jx, y: jy, rect: highlight });
              }
              // â€¦sidesteps omitted for clarityâ€¦
            } else {
              const highlight = this.add.rectangle(
                nx * CELL_SIZE + CELL_SIZE / 2,
                ny * CELL_SIZE + CELL_SIZE / 2,
                CELL_SIZE,
                CELL_SIZE,
                this.highlightColors[this.currentPlayer],
                0.4
              );
              highlight.setDepth(1);
              highlight.setInteractive(); // <-- add interactivity!

              // ðŸ‘‰ Handle mouse hover
              highlight.on("pointerout", () => {
                highlight.setFillStyle(
                  this.highlightColors[this.currentPlayer],
                  0.4
                );
              });
              highlight.on("pointerover", () => {
                highlight.setFillStyle(
                  this.highlightColors[this.currentPlayer],
                  0.8
                );
                this.keySound.play();
              });

              this.gridHighlights.push({ x: nx, y: ny, rect: highlight });
            }
          }
        }

        handleClick(pointer, gameObject) {
          if (this.wallMode) return; // prevent wall placement via click here

          // ðŸ‘‰ Hide the keyboard selector when moving by mouse
          this.selector.setVisible(false);

          // Calculate which tile was clicked using pointer position
          const targetX = Math.floor(pointer.x / CELL_SIZE);
          const targetY = Math.floor(pointer.y / CELL_SIZE);

          // Wall placement takes priority
          if (this.wallMode) {
            const placed = this.placeWall(targetX, targetY);
            if (!placed) {
              this.playInvalidSoundOnce();
            } else {
              this.wallMode = false;
              this.currentPlayer = 1 - this.currentPlayer;
              this.updateTurnIndicator();
              this.highlightMovableCells();
              this.wallSound.play();
            }
            return;
          }

          // Make sure the clicked cell is one of the allowed movement positions
          const isHighlighted = this.gridHighlights.some(
            (h) => h.x === targetX && h.y === targetY
          );
          if (!isHighlighted) {
            this.playInvalidSoundOnce();
            return;
          }

          // Check if there's a wall in the way (should be unnecessary, but safe)
          const player = this.pawns[this.currentPlayer];
          if (this.isWallBetween(player.x, player.y, targetX, targetY)) return;

          // Valid move â€” update player position
          player.x = targetX;
          player.y = targetY;
          player.sprite.setPosition(
            targetX * CELL_SIZE + CELL_SIZE / 2,
            targetY * CELL_SIZE + CELL_SIZE / 2
          );
          this.moveSound.play();

          // Victory check
          if (
            (this.currentPlayer === 0 && targetY === GRID_SIZE - 1) ||
            (this.currentPlayer === 1 && targetY === 0)
          ) {
            this.showVictory(this.currentPlayer + 1);
            return;
          }

          // End turn
          this.currentPlayer = 1 - this.currentPlayer;
          this.wallMode = false;
          this.updateTurnIndicator();
          this.highlightMovableCells();
        }
        isLegalWallPlacement(key, adjacentKey) {
          // Temporarily add the wall
          this.wallMap.add(key);
          this.wallMap.add(adjacentKey);

          const p1 = this.pawns[0];
          const p2 = this.pawns[1];

          const p1CanReach = this.hasPathToGoal(p1.x, p1.y, GRID_SIZE - 1);
          const p2CanReach = this.hasPathToGoal(p2.x, p2.y, 0);

          // Remove simulated wall
          this.wallMap.delete(key);
          this.wallMap.delete(adjacentKey);

          return p1CanReach && p2CanReach;
        }

        hasPathToGoal(startX, startY, goalY) {
          const visited = new Set();
          const queue = [[startX, startY]];

          while (queue.length > 0) {
            const [x, y] = queue.shift();
            const key = `${x},${y}`;
            if (visited.has(key)) continue;
            visited.add(key);

            if (y === goalY) return true;

            const directions = [
              { dx: 1, dy: 0 },
              { dx: -1, dy: 0 },
              { dx: 0, dy: 1 },
              { dx: 0, dy: -1 },
            ];

            for (const dir of directions) {
              const nx = x + dir.dx;
              const ny = y + dir.dy;

              const wallKey =
                dir.dx !== 0
                  ? `${Math.min(x, nx)},${y},V`
                  : `${x},${Math.min(y, ny)},H`;

              if (
                nx >= 0 &&
                ny >= 0 &&
                nx < GRID_SIZE &&
                ny < GRID_SIZE &&
                !this.wallMap.has(wallKey)
              ) {
                queue.push([nx, ny]);
              }
            }
          }

          return false;
        }

        placeWall(x, y) {
          if (this.wallCounts[this.currentPlayer] <= 0) return false;

          const key = `${x},${y},${this.wallOrientation}`;
          const adjacentKey =
            this.wallOrientation === "H"
              ? `${x + 1},${y},H`
              : `${x},${y + 1},V`;

          if (this.wallMap.has(key) || this.wallMap.has(adjacentKey))
            return false;

          if (
            (this.wallOrientation === "H" &&
              (x >= GRID_SIZE - 1 || y >= GRID_SIZE - 1)) ||
            (this.wallOrientation === "V" &&
              (x >= GRID_SIZE - 1 || y >= GRID_SIZE - 1))
          )
            return false;

          // --- PATHFINDING SAFEGUARD ---
          if (!this.isLegalWallPlacement(key, adjacentKey)) {
            return false;
          }

          // --- Continue only if path is legal ---
          // **Register the wall so movement checks block it**
          this.wallMap.add(key);
          this.wallMap.add(adjacentKey);

          // Visual wall placement
          let wall = null;
          const color = this.wallColors[this.currentPlayer];
          if (this.wallOrientation === "H") {
            wall = this.add.rectangle(
              x * CELL_SIZE + CELL_SIZE,
              y * CELL_SIZE + CELL_SIZE - WALL_THICKNESS / 2,
              CELL_SIZE * 2,
              WALL_THICKNESS,
              color
            );
          } else {
            wall = this.add.rectangle(
              x * CELL_SIZE + CELL_SIZE - WALL_THICKNESS / 2,
              y * CELL_SIZE + CELL_SIZE,
              WALL_THICKNESS,
              CELL_SIZE * 2,
              color
            );
          }

          this.walls.push(wall);
          this.wallCounts[this.currentPlayer]--;
          this.renderWallBars(); // inside placeWall()
          return true;
          console.log("Trying to place wall at", x, y);
          console.log("Player 1 at:", this.pawns[0].x, this.pawns[0].y);
          console.log("Player 2 at:", this.pawns[1].x, this.pawns[1].y);
        }

        isWallBetween(x1, y1, x2, y2) {
          console.log(
            `isWallBetween: (${x1},${y1}) â†’ (${x2},${y2}) checking keysâ€¦`
          );

          const dx = x2 - x1;
          const dy = y2 - y1;

          // Horizontal move
          if (dx === 1 && dy === 0) return this.wallMap.has(`${x1},${y1},V`);
          if (dx === -1 && dy === 0) return this.wallMap.has(`${x2},${y2},V`);

          // Vertical move
          if (dx === 0 && dy === 1) return this.wallMap.has(`${x1},${y1},H`);
          if (dx === 0 && dy === -1) return this.wallMap.has(`${x2},${y2},H`);

          // Horizontal jump
          if (dx === 2 && dy === 0)
            return (
              this.wallMap.has(`${x1},${y1},V`) ||
              this.wallMap.has(`${x1 + 1},${y1},V`)
            );
          if (dx === -2 && dy === 0)
            return (
              this.wallMap.has(`${x2},${y2},V`) ||
              this.wallMap.has(`${x2 + 1},${y2},V`)
            );

          // Vertical jump
          if (dx === 0 && dy === 2)
            return (
              this.wallMap.has(`${x1},${y1},H`) ||
              this.wallMap.has(`${x1},${y1 + 1},H`)
            );
          if (dx === 0 && dy === -2)
            return (
              this.wallMap.has(`${x2},${y2},H`) ||
              this.wallMap.has(`${x2},${y2 + 1},H`)
            );

          // Diagonal moves
          if (Math.abs(dx) === 1 && Math.abs(dy) === 1)
            return (
              this.wallMap.has(`${Math.min(x1, x2)},${y1},V`) ||
              this.wallMap.has(`${x1},${Math.min(y1, y2)},H`)
            );

          return true; // block everything else
        }

        updateTurnIndicator() {
          document.getElementById(
            "turnIndicator"
          ).innerText = `Current Turn: Player ${
            this.currentPlayer + 1
          }\nWalls left: ${this.wallCounts[this.currentPlayer]}\nWall mode: ${
            this.wallMode ? "ON" : "OFF"
          } (${this.wallOrientation})`;
        }

        // Show victory message modal
        /* showVictory(player) {
          alert(`Player ${player} wins!`);
          location.reload();
        } */

        showVictory(player) {
          const W = GRID_SIZE * CELL_SIZE;
          const H = GRID_SIZE * CELL_SIZE;
          const centerX = W / 2;
          const centerY = H / 2;

          // Stop the game music
          if (this.music) {
            this.music.stop();
          }
          // Stop any existing background music
          if (bgMusic && bgMusic.isPlaying) {
            bgMusic.stop();
          }
          // Play victory sound
          this.victoryMusic = this.sound.add("victorySound", {
            loop: true,
            volume: 1,
          });
          this.victoryMusic.play();

          // 1. Block board interaction
          const blocker = this.add
            .zone(centerX, centerY, W, H)
            .setInteractive()
            .setDepth(9);

          // 2. Dark overlay
          this.add
            .rectangle(centerX, centerY, W, H, 0x000000, 0.6)
            .setDepth(10);

          // 3. Modal container
          const modal = this.add.container(centerX, centerY).setDepth(11);
          modal.setAlpha(0); // start transparent

          // 4. Modal background
          const bg = this.add
            .rectangle(0, 0, 300, 150, 0x000000)
            .setStrokeStyle(4, 0x000000);
          modal.add(bg);

          // 5. Text
          const msg = this.add
            .text(0, -30, `Player ${player} wins!`, {
              fontFamily: "returnofganon",
              fontSize: "28px",
              color: "#fff",
              fontStyle: "bold",
            })
            .setOrigin(0.5);
          modal.add(msg);

          // 6. Restart button
          const btn = this.add
            .text(0, 30, "Restart", {
              fontFamily: "returnofganon",
              fontSize: "24px",
              color: "#ffffff",
              backgroundColor: "#32a852",
              padding: { x: 12, y: 6 },
            })
            .setOrigin(0.5)
            .setInteractive({ useHandCursor: true });
          modal.add(btn);

          btn.on("pointerdown", () => {
            if (this.victoryMusic) {
              this.victoryMusic.stop();
              this.victoryMusic.destroy();
              this.wallSound.play();
              this.victoryMusic = null;
            }

            this.scene.restart();
          });

          // 7. Fade in the modal
          this.tweens.add({
            targets: modal,
            alpha: 1,
            duration: 600,
            ease: "Power2",
          });
        }
        update(time, delta) {
          if (!this.selectorVisible) return;

          // Always decrease cooldown
          if (this.moveCooldown > 0) {
            this.moveCooldown -= delta;
            if (this.moveCooldown < 0) {
              this.moveCooldown = 0;
            }
          }

          // Only allow move if cooldown has expired
          if (this.moveCooldown === 0) {
            if (this.cursors.left.isDown) {
              this.tryMoveSelector(-1, 0);
              this.moveCooldown = 150;
              this.keySound.play();
            } else if (this.cursors.right.isDown) {
              this.tryMoveSelector(1, 0);
              this.moveCooldown = 150;
              this.keySound.play();
            } else if (this.cursors.up.isDown) {
              this.tryMoveSelector(0, -1);
              this.moveCooldown = 150;
              this.keySound.play();
            } else if (this.cursors.down.isDown) {
              this.tryMoveSelector(0, 1);
              this.moveCooldown = 150;
              this.keySound.play();
            }
          }
        }

        // Move selector
        tryMoveSelector(dx, dy) {
          if (this.wallMode) {
            // Wall mode: free movement
            const newX = this.selector.gridX + dx;
            const newY = this.selector.gridY + dy;
            if (
              newX >= 0 &&
              newY >= 0 &&
              newX < GRID_SIZE &&
              newY < GRID_SIZE
            ) {
              this.selector.gridX = newX;
              this.selector.gridY = newY;
              this.updateSelectorPosition();
            }
          } else {
            // Move mode: flexible search
            const currentX = this.selector.gridX;
            const currentY = this.selector.gridY;

            let closest = null;
            let closestDist = Infinity;

            for (const h of this.gridHighlights) {
              const diffX = h.x - currentX;
              const diffY = h.y - currentY;

              // Only consider squares generally in the pressed direction
              if (
                (dx === -1 && diffX >= 0) || // left: ignore right
                (dx === 1 && diffX <= 0) || // right: ignore left
                (dy === -1 && diffY >= 0) || // up: ignore down
                (dy === 1 && diffY <= 0) // down: ignore up
              ) {
                continue;
              }

              const dist = Math.abs(diffX) + Math.abs(diffY); // Manhattan distance

              if (dist < closestDist) {
                closestDist = dist;
                closest = h;
              }
            }

            if (closest) {
              this.selector.gridX = closest.x;
              this.selector.gridY = closest.y;
              this.updateSelectorPosition();
            }
          }
        }

        updateSelectorPosition() {
          if (!this.wallMode) {
            this.selector.setVisible(true);
            this.selector.x = this.selector.gridX * CELL_SIZE + CELL_SIZE / 2;
            this.selector.y = this.selector.gridY * CELL_SIZE + CELL_SIZE / 2;
            this.selector.setFillStyle(
              this.wallColors[this.currentPlayer],
              0.4
            );
          } else {
            this.selector.setVisible(false);
          }

          if (this.wallMode) {
            this.updateGhostWall();
          }
        }

        updateGhostWall() {
          const x = this.selector.gridX;
          const y = this.selector.gridY;

          if (x < 0 || y < 0 || x >= GRID_SIZE - 1 || y >= GRID_SIZE - 1) {
            if (this.ghostWall) this.ghostWall.setAlpha(0);
            return;
          }

          const key = `${x},${y},${this.wallOrientation}`;
          const adjacentKey =
            this.wallOrientation === "H"
              ? `${x + 1},${y},H`
              : `${x},${y + 1},V`;

          const isInvalid =
            this.wallMap.has(key) || this.wallMap.has(adjacentKey);

          if (!this.ghostWall) {
            this.ghostWall = this.add.rectangle(
              0,
              0,
              0,
              0,
              this.wallColors[this.currentPlayer]
            );
            this.ghostWall.setAlpha(0.4);
            this.ghostWall.setDepth(1.5);
          }

          if (this.wallOrientation === "H") {
            this.ghostWall.setSize(CELL_SIZE * 2, WALL_THICKNESS);
            this.ghostWall.setPosition(
              x * CELL_SIZE + CELL_SIZE,
              y * CELL_SIZE + CELL_SIZE - WALL_THICKNESS / 2
            );
          } else {
            this.ghostWall.setSize(WALL_THICKNESS, CELL_SIZE * 2);
            this.ghostWall.setPosition(
              x * CELL_SIZE + CELL_SIZE - WALL_THICKNESS / 2,
              y * CELL_SIZE + CELL_SIZE
            );
          }

          this.ghostWall.setFillStyle(this.wallColors[this.currentPlayer]);

          if (isInvalid) {
            this.ghostWall.setAlpha(0.2); // Make it flashier that it's wrong
          } else {
            this.ghostWall.setAlpha(0.4);
          }
        }

        // Action when pressing Space
        handleSelectorAction() {
          if (this.wallMode) {
            const x = this.selector.gridX;
            const y = this.selector.gridY;
            const placed = this.placeWall(x, y);

            if (placed) {
              this.wallMode = false;
              this.currentPlayer = 1 - this.currentPlayer;
              this.updateTurnIndicator();
              this.highlightMovableCells();
              this.selector.gridX = this.pawns[this.currentPlayer].x;
              this.selector.gridY = this.pawns[this.currentPlayer].y;
              this.updateSelectorPosition();
              this.wallSound.play();
            } else {
              this.playInvalidSoundOnce();
            }
          } else {
            // Move player
            const targetX = this.selector.gridX;
            const targetY = this.selector.gridY;

            const isHighlighted = this.gridHighlights.some(
              (h) => h.x === targetX && h.y === targetY
            );
            if (!isHighlighted) {
              this.playInvalidSoundOnce();
              return;
            }

            const player = this.pawns[this.currentPlayer];
            if (this.isWallBetween(player.x, player.y, targetX, targetY))
              return;

            player.x = targetX;
            player.y = targetY;
            player.sprite.setPosition(
              targetX * CELL_SIZE + CELL_SIZE / 2,
              targetY * CELL_SIZE + CELL_SIZE / 2
            );
            this.moveSound.play();

            if (
              (this.currentPlayer === 0 && targetY === GRID_SIZE - 1) ||
              (this.currentPlayer === 1 && targetY === 0)
            ) {
              this.showVictory(this.currentPlayer + 1);
              return;
            }

            this.currentPlayer = 1 - this.currentPlayer;
            this.wallMode = false;
            this.updateTurnIndicator();
            this.highlightMovableCells();
            this.selector.gridX = this.pawns[this.currentPlayer].x;
            this.selector.gridY = this.pawns[this.currentPlayer].y;
            this.updateSelectorPosition();
          }
        }
      }

      const config = {
        type: Phaser.AUTO,
        width: GRID_SIZE * CELL_SIZE,
        height: GRID_SIZE * CELL_SIZE,
        parent: "game-container", // Add this line to mount canvas into the right spot

        backgroundColor: "#1d1d1d",
        scene: QuoridorScene,
      };

      //new Phaser.Game(config);
      window.game = new Phaser.Game(config);
    </script>
  </body>
</html>
